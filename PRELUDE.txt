(*) number1 number2
comment: any two numbers -> mathematical multiplication function
(always)
(003) "*" number1 number2

(+) number1 number2
comment: any two numbers -> mathematical addition function
(always)
(003) "+" number1 number2

(-) number1 number2
comment: any two numbers -> mathematical subtraction function
(always)
(003) "-" number1 number2

(-10) list
comment: any list -> selects the tenth tail of list
(always)
(tails) 10 list

(-2) list
comment: any list -> selects the second tail of list
(always)
(tails) 2 list

(-3) list
comment: any list -> selects the third tail of list
(always)
(tails) 3 list

(-4) list
comment: any list -> selects the fourth tail of list
(always)
(tails) 4 list

(-5) list
comment: any list -> selects the fifth tail of list
(always)
(tails) 5 list

(-6) list
comment: any list -> selects the sixth tail of list
(always)
(tails) 6 list

(-7) list
comment: any list -> selects the seventh tail of list
(always)
(tails) 7 list

(-8) list
comment: any list -> selects the eighth tail of list
(always)
(tails) 8 list

(-9) list
comment: any list -> selects the ninth tail of list
(always)
(tails) 9 list

(/) number1 number2
comment: any two numbers -> mathematical division function
(always)
(003) "/" number1 number2

(10) list
comment: any list -> selects the tenth item of list
(always)
(ref) 10 list

(2) list
comment: any list -> selects the second item of list
(always)
(ref) 2 list

(3) list
comment: any list -> selects the third item of list
(always)
(ref) 3 list

(4) list
comment: any list -> selects the fourth item of list
(always)
(ref) 4 list

(5) list
comment: any list -> selects the fifth item of list
(always)
(ref) 5 list

(6) list
comment: any list -> selects the sixth item of list
(always)
(ref) 6 list

(7) list
comment: any list -> selects the seventh item of list
(always)
(ref) 7 list

(8) list
comment: any list -> selects the eighth item of list
(always)
(ref) 8 list

(9) list
comment: any list -> selects the ninth item of list
(always)
(ref) 9 list

(<) number1 number2
comment: any two numbers -> mathematical less-than function
(always)
(003) "<" number1 number2

(>) number1 number2
comment: any two numbers -> mathematical greater-than function
(always)
(003) ">" number1 number2

(add-between) item list
comment: empty list -> construct a list with item inserted between the members of the input list
(null?) list
nil

(add-between) item list
comment: one element list -> construct a list with item inserted between the members of the input list
(null?) (!) list
list

(add-between) item list
comment: multi element list -> construct a list with item inserted between the members of the input list
(not) (null?) (!) list
(c) (1) list
    (c) item
        (add-between) item (!) list

(add1) number
comment: any number -> mathematical increment function
(always)
(002) "add1" number

(append) list1 list2
comment: empty list1 -> concatenate two lists
(null?) list1
list2

(append) list1 list2
comment: non empty list1 -> concatenate two lists
(always)
(c) (1) list1 (append) (!) list1 list2

(append-output-file) path
comment: a valid path -> open a file for output in append mode
(always)
(004) "open-output-file"
      path
      "#:exists"
      "'append"

(bit) generator
comment: generator encapsulates a state of the random number generator -> output is a random boolean
(always)
(=) 2 (random) generator 2

(bits) runs
comment: runs is a list of positive integers -> output is a list of booleans representing the runs
(always)
(reduce-append) (ZEDbits) runs

(ZEDbits) runs
comment: empty runs -> output is a list of lists of booleans representing the runs
(null?) runs
nil

(ZEDbits) runs
comment: non empty runs -> output is a list of lists of booleans representing the runs
(always)
(c) (append) (repeat) (sub1) (1) runs
                      #true
             (wrap) #false
    (ZEDbits) (!) runs

(bits->byte) bits
comment: bits is a list of booleans -> output is the base ten integer corresponding to the bit pattern
(always)
(ZEDbits->byte) bits 0

(ZEDbits->byte) bits accumulator
comment: empty bits -> accumulator
(null?) bits
accumulator

(ZEDbits->byte) bits accumulator
comment: first bit is #true -> double the accumulator and increment, then recur on the rest of the bits
(1) bits
(ZEDbits->byte) (!) bits
                (add1) (*) 2 accumulator

(ZEDbits->byte) bits accumulator
comment: first bit is #false -> double the accumulator and then recur on the rest of the bits
(always)
(ZEDbits->byte) (!) bits
                (*) 2 accumulator

(bits->bytes) bits
comment: bits is a list of booleans -> output is the bytes
(always)
(mp) bits->byte (ZEDbits->bytes) bits

(ZEDbits->bytes) bits
comment: empty bits ->  return the empty list
(null?) bits
nil

(ZEDbits->bytes) bits
comment: non empty bits -> output is a list of eight element lists of booleans
(always)
(c) (first) 8 bits
    (ZEDbits->bytes) (-8) bits

(boolean?) value
comment: any value -> is the value a boolean?
(always)
(002) "boolean?" value

(byte->bits) byte
comment: byte is an integer in the range 0-255 -> output is an eight element list of booleans
(always)
(append) (repeat) (-) 8 (length) (ZEDbyte->bits) byte
                  #false
         (reverse) (ZEDbyte->bits) byte

(ZEDbyte->bits) byte
comment: byte is zero -> return the empty list
(zero?) byte
nil

(ZEDbyte->bits) byte
comment: byte is odd -> cons #true and recur appropriately
(odd?) byte
(c) #true (ZEDbyte->bits) (halve) (sub1) byte

(ZEDbyte->bits) byte
comment: byte is even -> cons #false and recur appropriately
(even?) byte
(c) #false (ZEDbyte->bits) (halve) byte

(byte-string->path) byte-string
comment: any byte-string that is a valid path -> a path object
(always)
(002) "bytes->path" byte-string

(byte-string-append) byte-string1 byte-string2
comment: takes two byte-strings -> outputs the concatenation
(always)
(003) "bytes-append" byte-string1 byte-string2

(bytes->bits) bytes
comment: bytes is a list of integers in the range 0-255 -> output is a list of booleans
(always)
(reduce-append) (mp) byte->bits bytes

(call-with-output-string) function-of-an-output-port
comment: takes a function of an output port -> returns the string resulting from applying the function
(always)
(002) "call-with-output-string" function-of-an-output-port

(character->integer) character
comment: any character -> outputs an integer that is the Unicode code-point number
(always)
(002) "char->integer" character

(character->string) character
comment: any character -> outputs a one character string
(always)
(002) "list->string" ("wrap") character

(character?) value
comment: any value -> is it a character?
(always)
(002) "char?" value

(close-input-port) port
comment: takes an input port -> closes it
(always)
(002) "close-input-port" port

(close-output-port) port
comment: takes an output port -> closes it
(always)
(002) "close-output-port" port

(collect-garbage)
comment: force garbage collection
(always)
(001) "collect-garbage"

(count) number
comment: start with a number -> the infinite list of numbers counting up by one
(always)
(c) number (count) (add1) number

(current-directory)
comment: returns the current directory path of the running program
(always)
(001) "current-directory"

(current-memory-use)
comment: returns a count of the bytes of memory occupied by reachable data
(always)
(001) "current-memory-use"

(current-random-number-generator)
comment: the current random number generator
(always)
(001) "current-pseudo-random-generator"

(curry) function
comment: takes a function -> returns the curried function
(always)
(002) "curry" function

(default-input-port)
comment: the default input port
(always)
(001) "current-input-port"

(default-output-port)
comment: the default output port
(always)
(001) "current-output-port"

(delay) value
comment: takes a value -> delays computation
(always)
(002) "delay" value

(delete-file) path
comment: a valid path -> file is deleted
(always)
(002) "delete-file" path

(delete-file-if-exists) path
comment: a valid path -> file is deleted if it exists
(file-exists?) path
(delete-file) path

(denominator) number
comment: takes an exact number -> returns the denominator
(always)
(002) "denominator" number

(display) port item
comment: takes an output port and an item -> displays item on the output port
(always)
(003) "display" item port

(dr) value
comment: any value -> display it to the default output port and then return it as a value
(always)
(se) (display) (default-output-port) (pr) (ZEDdr) value
     (se) (newline) (default-output-port)
     (se) (newline) (default-output-port)
     value

(ZEDdr) value
comment: value is a pair -> recursively gather upto the first 64 elements of value
(pair?) value
(mp) ZEDdr (first) 64 value

(ZEDdr) value
comment: value is basic -> return the value
(always)
value

(drr) value
comment: any value that is not infinite -> display then return the value
(always)
(se) (display) (default-output-port) (pr) value
     (se) (newline) (default-output-port)
     (se) (newline) (default-output-port)
     value

(end-of-file-object)
comment: end of file object
(always)
"eof"

(end-of-file-object?) value
comment: any value -> is it the end of file object?
(always)
(002) "eof-object?" value

(eq?) symbol1 symbol2
comment: any two symbols -> are they the same symbol?
(always)
(003) "eq?" symbol1 symbol2

(equal?) list1 list2
comment: either list empty -> are the two lists displayed the same?
(or) (null?) list1 (null?) list2
(and) (null?) list1 (null?) list2

(equal?) list1 list2
comment: list1 is not a pair -> are the two lists displayed the same?
(or) (not) (pair?) list1 (not) (pair?) list2
("equal?") list1 list2

(equal?) list1 list2
comment: the first elements of list1 and list2 are recursively (equal?) -> are the two lists displayed the same?
(always)
(and) (equal?) (1) list1 (1) list2
      (equal?) (!) list1 (!) list2

(even?) integer
comment: any integer -> is the integer even?
(always)
(002) "even?" integer

(exact->inexact) number
comment: an exact number -> returns the inexact representation
(always)
(002) "exact->inexact" number

(fi) function list
comment: empty list -> returns the list of elements that satisfy the function
(null?) list
nil

(fi) function list
comment: first element of list satisfies function -> returns the list of elements that satisfy the function
(002) function (1) list
(c) (1) list (fi) function (!) list

(fi) function list
comment: first element of list does not satisfy function -> returns the list of elements that satisfy the function
(always)
(fi) function (!) list

(file-exists?) path
comment: any path -> does the file exist?
(always)
(002) "file-exists?" path

(file-size) path
comment: any valid path -> returns the file size in bytes
(always)
(002) "file-size" path

(first) integer list
comment: list is not a list -> selects the first integer elements from the beginning of list
(not) (pair?) list
list

(first) integer list
comment: integer is zero -> selects the first integer elements from the beginning of list
(zero?) integer
nil

(first) integer list
comment: integer is positive -> selects the first integer elements from the beginning of list
(positive?) integer
(c) (1) list
    (first) (sub1) integer
            (!) list

(force) value
comment: takes a value -> forces a promise or returns the value
(always)
(002) "force" value

(generate-symbol) base
comment: takes a string or symbol base -> generates a symbol gaurenteed to be unique for the purpose of comparisons
(always)
(002) "gensym" base

(get-file) message
comment: takes a message string -> returns a file path object
(always)
(002) "get-file" message

(get-run) bits
comment: first bit is #true -> returns the first run in bits
(1) bits
(+) 1 (get-run) (!) bits

(get-run) bits
comment: first bit is #false -> returns the first run in bits
(always)
1

(get-text-from-user) title message
comment: provide a title and a message -> returns a string of the user input
(always)
(003) "get-text-from-user" title message

(gr) garbage value
comment: takes a value and a garbage value -> returns the value after displaying the garbage value with (dr)
(always)
(se) (dr) garbage value

(grr) garbage value
comment: takes a value and a garbage value -> returns the value after displaying the garbage value with (drr)
(always)
(se) (drr) garbage value

(halve) number
comment: any number -> returns half
(always)
(/) number 2

(last) list
comment: empty list -> last element of list
(null?) list
err

(last) list
comment: single element list -> last element of list
(null?) (!) list
(1) list

(last) list
comment: multi element list -> last element of list
(always)
(last) (!) list

(length) list
comment: empty list -> returns the length of the list
(null?) list
0

(length) list
comment: non empty list -> returns the length of the list
(always)
(add1) (length) (!) list

(list->string) list
comment: takes a list -> returns a string representation of the non list parts
(always)
("apply") "string-append" (002) "flatten" (ZEDlist->string) list

(ZEDlist->string) list
comment: empty list -> returns almost the same list structure but with strings replacing the atoms
(null?) list
nil

(ZEDlist->string) list
comment: list is not a pair -> returns almost the same list structure but with strings replacing the atoms
(not) (pair?) list
(ZEDlist->string) (wrap2) "","" list

(ZEDlist->string) list
comment: the first element of list is the empty list -> returns almost the same list structure but with strings replacing the atoms
(null?) (1) list
(ZEDlist->string) (!) list

(ZEDlist->string) list
comment: the first element of list is a pair -> returns almost the same list structure but with strings replacing the atoms
(pair?) (1) list
("cons") (ZEDlist->string) (1) list
         (ZEDlist->string) (!) list

(ZEDlist->string) list
comment: the first element of list is not a pair -> returns almost the same list structure but with strings replacing the atoms
(always)
("cons") (call-with-output-string) (002) (curry) "display" (1) list
         (ZEDlist->string) (!) list

(list?) value
comment: empty list -> is value a list?
(null?) value
#true

(list?) value
comment: value is a pair -> is value a list?
(pair?) value
(list?) (!) value

(list?) value
comment: value is not a pair -> is value a list?
(always)
#false

(make-random-number-generator)
comment: makes a random number generator object
(always)
(001) "make-pseudo-random-generator"

(many) function count value
comment: count is less than one -> returns the value after applying function count times
(<) count 1
value

(many) function count value
comment: count is not less than one -> returns the value after applying function count times
(always)
(many) function (sub1) count (002) function value

(maximum) number1 number2
comment: any two numbers -> returns the maximum of the two
(always)
(003) "max" number1 number2

(member?) value list
comment: empty list -> is value a member of the list?
(null?) list
#false

(member?) value list
comment: the first member of list is value by comparison (=) -> is value a member of the list?
(=) value (1) list
#true

(member?) value list
comment: the first member of list is not value by comparison (=) -> is value a member of the list?
(always)
(member?) value (!) list

(message) list
comment: list is the words of a message -> returns the string which is the words of the message seperated by spaces
(always)
(list->string) (add-between) #space list

(message-box) title message
comment: given a title and message -> produces a message box
(always)
(003) "message-box" title message

(modulo) integer1 integer2
comment: given integer1 and integer2 -> returns integer1 modulo integer2
(always)
(003) "modulo" integer1 integer2

(mp) function list
comment: empty list -> returns the list with every element transformed by function
(null?) list
nil

(mp) function list
comment: list is a pair -> returns the list with every element transformed by function
(pair?) list
(c) (002) function (1) list
    (mp) function (!) list

(mp) function list
comment: list is not a pair -> returns the list with every element transformed by function
(always)
(002) function list

(multiple?) number1 number2
comment: given number1 and number2 -> is number2 an exact multiple of number1?
(always)
(=) 1 (denominator) (/) number2 number1

(negative?) number
comment: any number -> is it negative?
(always)
(<) number 0

(newline) port
comment: takes an output port -> sends a newline to it
(always)
(002) "newline" port

(non) runs
comment: the first run is one -> produces the first integer not equal to one
(=) 1 (1) runs
(non) (!) runs

(non) runs
comment: the first run is greater than one -> produces the first integer not equal to one
(always)
(1) runs

(not) boolean
comment: takes a boolean value -> gives the compliment
(always)
(002) "not" boolean

(null?) value
comment: any value -> is it the empty list?
(always)
(002) "null?" value

(number->string) number
comment: any number -> returns a string representation
(always)
(002) "number->string" number

(number?) value
comment: any value -> is value a number?
(always)
(002) "number?" value

(odd?) integer
comment: takes an integer -> is it odd?
(always)
(002) "odd?" integer

(ones) runs
comment: the first run is one -> returns count of leading ones
(=) 1 (1) runs
(add1) (ones) (!) runs

(ones) runs
comment: the first run is not a one -> returns count of leading ones
(always)
0

(open-input-file) path
comment: path to a file -> opens an input port
(always)
(002) "open-input-file" path

(open-output-file) path
comment: path to a file that does not exist -> opens an output port
(always)
(002) "open-output-file" path

(pair?) value
comment: any value -> is it a pair?
(always)
(002) "pair?" value

(path->byte-string) path
comment: takes a path object -> produces a byte-string
(always)
(002) "path->bytes" path

(positive?) number
comment: any number -> is it positive?
(always)
(>) number 0

(pr) value
comment: any value -> returns a string representation
(always)
(call-with-output-string) (002) (curry) "display" (zed->racket) value

(predictable-random-bits) seed
comment: takes a seed for the random number generator -> produces an infinite list of rsndom bits
(always)
(se) (002) "current-pseudo-random-generator" (make-random-number-generator)
     (se) (random-seed) seed
     (ZEDpredictable-random-bits1) (current-random-number-generator)

(ZEDpredictable-random-bits1) generator
comment: takes a random number generator -> produces an infinite list of random bits
(always)
(ZEDpredictable-random-bits2) (bit) generator generator

(ZEDpredictable-random-bits2) bit generator
comment: takes a bit and a random number generator -> produces an infinite list of random bits
(always)
(c) bit (ZEDpredictable-random-bits1) generator

(put-file) message
comment: takes a message -> returns a path to a filename which may or may not exist
(always)
(002) "put-file" message

(quotient) integer1 integer2
comment: takes two integers -> returns the quotient
(always)
(003) "quotient" integer1 integer2

(raise) number1 number2
comment: takes a base and a power -> returns number1 raised to the number2 power
(always)
(003) "expt" number1 number2

(random) generator integer
comment: takes a random number generator and an integer -> produces a positive integer
(always)
(add1) (003) "random" integer generator

(random-number-generator->vector) generator
comment: takes a random number generator -> returns a vector of its internal state
(always)
(002) "pseudo-random-generator->vector" generator

(random-number-generator-vector?) value
comment: any value -> is it a valid state of the random number generator?
(always)
(002) "pseudo-random-generator-vector?" value

(random-number-generator?) value
comment: any value -> is it a random number generator?
(always)
(002) "pseudo-random-generator?" value

(random-seed) integer
comment: takes a positive integer less than the power two to the thirty-one -> seeds the current random number generator
(always)
(002) "random-seed" integer

(rd) final function list
comment: takes a list and a two argument function -> accumulates the final value using function
(always)
(004) "foldr" function final (zed->racket) list

(read) port
comment: an input port -> reads in a single datum
(always)
(002) "read" port

(read-byte) port
comment: an input port -> reads in a single byte
(always)
(002) "read-byte" port

(read-bytes) path
comment: takes a file path -> opens the file and reads in the bytes
(always)
(ZEDread-bytes1) (open-input-file) path

(ZEDread-bytes1) port
comment: takes an input port -> reads in the bytes until end of file
(always)
(ZEDread-bytes2) port (read-byte) port

(ZEDread-bytes2) port byte
comment: reached end of file -> read in the bytes
(end-of-file-object?) byte
(se) (close-input-port) port nil

(ZEDread-bytes2) port byte
comment: haven't reached end of file -> read in the bytes
(always)
(c) byte (ZEDread-bytes1) port

(reduce) final function list
comment: takes a list and a two argument function -> accumulates the final value using function
(always)
(004) "foldr" function final (zed->racket) list

(reduce-append) list
comment: takes a list -> accumulates a value by appending the sub lists together
(always)
(reduce) nil append list

(ref) integer list
comment: integer equals one -> selects the specified element of list
(=) integer 1
(1) list

(ref) integer list
comment: integer is greater than one -> selects the specified element of list
(>) integer 1
(ref) (sub1) integer (!) list

(remove) value list
comment: empty list -> removes the first occurrence of value in list
(null?) list
nil

(remove) value list
comment: first element of list is value -> removes the first occurrence of value in list
(=) value (1) list
(!) list

(remove) value list
comment: first element of list is not value -> removes the first occurrence of value in list
(always)
(c) (1) list (remove) value (!) list

(remove-with-equal) value list
comment: empty list -> removes the first occurrence of value in list
(null?) list
nil

(remove-with-equal) value list
comment: first element of list is value by comparison (equal?) -> removes the first occurrence of value in list
(equal?) value (1) list
(!) list

(remove-with-equal) value list
comment: first element of list is not value by comparison (equal?) -> removes the first occurrence of value in list
(always)
(c) (1) list (remove-with-equal) value (!) list

(repeat) integer item
comment: integer is zero -> returns the list of repeated items
(zero?) integer
nil

(repeat) integer item
comment: integer is positive -> returns the list of repeated items
(positive?) integer
(c) item (repeat) (sub1) integer item

(replace-output-file) path
comment: takes a file path -> opens a file for output in replace mode
(always)
(004) "open-output-file"
      path
      "#:exists"
      "'replace"

(reverse) list
comment: a finite list -> returns the list in reverse order
(always)
(ZEDreverse) list nil

(ZEDreverse) list reverse
comment: empty list -> returns list in reverse
(null?) list
reverse

(ZEDreverse) list reverse
comment: non empty list -> returns list in reverse
(always)
(ZEDreverse) (!) list
             (c) (1) list reverse

(runs) bits
comment: takes a sequence of bits (#true or #false) -> returns run lengths to #false
(always)
(ZEDruns) bits (get-run) bits

(ZEDruns) bits run
comment: empty bits -> returns run lengths to #false
(null?) bits
nil

(ZEDruns) bits run
comment: non empty bits -> returns run lengths to #false
(always)
(c) run (runs) (tails) run bits

(sort) comparator list
comment: takes a comparator function and a list -> sorts the list using the comparator
(always)
(003) "sort" (zed->racket) list comparator

(sp)
comment: returns the string with one space in it
(always)
(character->string) #space

(space) port
comment: takes an output port -> sends the #space character
(always)
(display) port #space

(square) number
comment: any number -> the mathematical square
(always)
(*) number number

(square-root) number
comment: any number -> mathematical square root
(always)
(002) "sqrt" number

(string->list) string
comment: takes a string -> returns a list of characters
(always)
(002) "string->list" string

(string?) value
comment: takes a value -> is it a string?
(always)
(002) "string?" value

(sub1) number
comment: takes a number -> returns the quantity number minus one
(always)
(002) "sub1" number

(sum) numbers
comment: takes a list of numbers -> adds them up
(always)
(reduce) 0 + numbers

(symbol->string) symbol
comment: any symbol -> returns an equivalent string
(always)
(002) "symbol->string" symbol

(symbol?) value
comment: any value -> is it a symbol?
(always)
(002) "symbol?" value

(tails) integer list
comment: empty list or integer is zero ->  the nth tail of list
(or) (null?) list
     (=) integer 0
list

(tails) integer list
comment: integer is positive -> the nth tail of list
(>) integer 0
(tails) (sub1) integer (!) list

(vector->random-number-generator) vector
comment: takes an appropriate vector -> returns a random number generator
(always)
(002) "vector->pseudo-random-generator" vector

(wrap) value
comment: takes a value -> makes a list
(always)
(002) "list" value

(wrap10) value1 value2 value3 value4 value5 value6 value7 value8 value9 value10
comment: takes ten values -> makes a list
(always)
(011) "list" value1 value2 value3 value4 value5 value6 value7 value8 value9 value10

(wrap11) value1 value2 value3 value4 value5 value6 value7 value8 value9 value10 value11
comment: takes eleven values -> makes a list
(always)
(012) "list" value1 value2 value3 value4 value5 value6 value7 value8 value9 value10 value11

(wrap12) value1 value2 value3 value4 value5 value6 value7 value8 value9 value10 value11 value12
comment: takes twelve values -> makes a list
(always)
(013) "list" value1 value2 value3 value4 value5 value6 value7 value8 value9 value10 value11 value12

(wrap13) value1 value2 value3 value4 value5 value6 value7 value8 value9 value10 value11 value12 value13
comment: takes thirteen values -> makes a list
(always)
(014) "list" value1 value2 value3 value4 value5 value6 value7 value8 value9 value10 value11 value12 value13

(wrap14) value1 value2 value3 value4 value5 value6 value7 value8 value9 value10 value11 value12 value13 value14
comment: takes fourteen values -> makes a list
(always)
(015) "list" value1 value2 value3 value4 value5 value6 value7 value8 value9 value10 value11 value12 value13 value14

(wrap15) value1 value2 value3 value4 value5 value6 value7 value8 value9 value10 value11 value12 value13 value14 value15
comment: takes fifteen values -> makes a list
(always)
(016) "list" value1 value2 value3 value4 value5 value6 value7 value8 value9 value10 value11 value12 value13 value14 value15

(wrap16) value1 value2 value3 value4 value5 value6 value7 value8 value9 value10 value11 value12 value13 value14 value15 value16
comment: takes sixteen values -> makes a list
(always)
(017) "list" value1 value2 value3 value4 value5 value6 value7 value8 value9 value10 value11 value12 value13 value14 value15 value16

(wrap2) value1 value2
comment: takes two values -> makes a list
(always)
(003) "list" value1 value2

(wrap3) value1 value2 value3
comment: takes three values -> makes a list
(always)
(004) "list" value1 value2 value3

(wrap4) value1 value2 value3 value4
comment: takes four values -> makes a list
(always)
(005) "list" value1 value2 value3 value4

(wrap5) value1 value2 value3 value4 value5
comment: takes five values -> makes a list
(always)
(006) "list" value1 value2 value3 value4 value5

(wrap6) value1 value2 value3 value4 value5 value6
comment: takes six values -> makes a list
(always)
(007) "list" value1 value2 value3 value4 value5 value6

(wrap7) value1 value2 value3 value4 value5 value6 value7
comment: takes seven values -> makes a list
(always)
(008) "list" value1 value2 value3 value4 value5 value6 value7

(wrap8) value1 value2 value3 value4 value5 value6 value7 value8
comment: takes eight values -> makes a list
(always)
(009) "list" value1 value2 value3 value4 value5 value6 value7 value8

(wrap9) value1 value2 value3 value4 value5 value6 value7 value8 value9
comment: takes nine values -> makes a list
(always)
(010) "list" value1 value2 value3 value4 value5 value6 value7 value8 value9

(write-byte) port byte
comment: takes a byte and an output port -> writes the byte to the output port
(always)
(003) "write-byte" byte port

(write-bytes) path bytes
comment: takes a file path and a list of bytes -> writes the bytes out to file
(always)
(ZEDwrite-bytes) (open-output-file) path bytes

(ZEDwrite-bytes) port bytes
comment: empty bytes -> writes the bytes out to the output port
(null?) bytes
(close-output-port) port

(ZEDwrite-bytes) port bytes
comment: non empty bytes -> writes the bytes out to the output port
(always)
(se) (write-byte) port (1) bytes
     (ZEDwrite-bytes) port (!) bytes

(xor) bit1 bit2
comment: takes two bits -> performs the exclusive or operation
(and) (boolean?) bit1
      (boolean?) bit2
(not) (=) bit1 bit2

(zed->racket) value
comment: value is empty list or atom -> returns a Racket value
(not) (pair?) value
value

(zed->racket) value
comment: value is non empty list -> returns a Racket value
(always)
("cons") (zed->racket) (1) value (zed->racket) (!) value

(zero?) number
comment: any number -> is it zero?
(always)
(=) number 0

(zip) bits1 bits2
comment: empty bits1 or empty bits2 -> returns the result of doing a bit by bit exclusive or
(or) (null?) bits1 (null?) bits2
nil

(zip) bits1 bits2
comment: matching bits -> returns the result of doing a bit by bit exclusive or
(always)
(c) (xor) (1) bits1 (1) bits2
    (zip) (!) bits1 (!) bits2