(*) number1 number2
comment: any two numbers -> mathematical multiplication function
(always)
(three) "*" number1 number2

(+) number1 number2
comment: any two numbers -> mathematical addition function
(always)
(three) "+" number1 number2

(-) number1 number2
comment: any two numbers -> mathematical subtraction function
(always)
(three) "-" number1 number2

(-10) list
comment: any list -> selects the tenth tail of list
(always)
(tails) 10 list

(-2) list
comment: any list -> selects the second tail of list
(always)
(tails) 2 list

(-3) list
comment: any list -> selects the third tail of list
(always)
(tails) 3 list

(-4) list
comment: any list -> selects the fourth tail of list
(always)
(tails) 4 list

(-5) list
comment: any list -> selects the fifth tail of list
(always)
(tails) 5 list

(-6) list
comment: any list -> selects the sixth tail of list
(always)
(tails) 6 list

(-7) list
comment: any list -> selects the seventh tail of list
(always)
(tails) 7 list

(-8) list
comment: any list -> selects the eighth tail of list
(always)
(tails) 8 list

(-9) list
comment: any list -> selects the ninth tail of list
(always)
(tails) 9 list

(/) number1 number2
comment: any two numbers -> mathematical division function
(always)
(three) "/" number1 number2

(10) list
comment: any list -> selects the tenth item of list
(always)
(ref) 10 list

(2) list
comment: any list -> selects the second item of list
(always)
(ref) 2 list

(3) list
comment: any list -> selects the third item of list
(always)
(ref) 3 list

(4) list
comment: any list -> selects the fourth item of list
(always)
(ref) 4 list

(5) list
comment: any list -> selects the fifth item of list
(always)
(ref) 5 list

(6) list
comment: any list -> selects the sixth item of list
(always)
(ref) 6 list

(7) list
comment: any list -> selects the seventh item of list
(always)
(ref) 7 list

(8) list
comment: any list -> selects the eighth item of list
(always)
(ref) 8 list

(9) list
comment: any list -> selects the ninth item of list
(always)
(ref) 9 list

(<) number1 number2
comment: any two numbers -> mathematical less-than function
(always)
(three) "<" number1 number2

(>) number1 number2
comment: any two numbers -> mathematical greater-than function
(always)
(three) ">" number1 number2

(add-between) item list
comment: empty list -> construct a list with item inserted between the members of the input list
(null?) list
nil

(add-between) item list
comment: one element list -> construct a list with item inserted between the members of the input list
(null?) (!) list
list

(add-between) item list
comment: multi element list -> construct a list with item inserted between the members of the input list
(not) (null?) (!) list
(c) (1) list
    (c) item
        (add-between) item (!) list
        
(add1) number
comment: any number -> mathematical increment function
(always)
(two) "add1" number

(append) list1 list2
comment: empty list1 -> concatenate two lists
(null?) list1
list2

(append) list1 list2
comment: non empty list1 -> concatenate two lists
(always)
(c) (1) list1 (append) (!) list1 list2   

(append-output-file) path
comment: a valid path -> open a file for output in append mode
(always)
(four) "open-output-file"
       path
       "#:exists"
       "'append"

(bit) generator
comment: generator encapsulates a state of the random number generator -> output is a random boolean
(always)
(=) 2 (random) generator 2

(bits) runs
comment: runs is a list of positive integers -> output is a list of booleans representing the runs
(always)
(reduce-append) (ZEDbits) runs

(ZEDbits) runs
comment: empty runs -> output is a list of lists of booleans representing the runs
(null?) runs
nil

(ZEDbits) runs
comment: non empty runs -> output is a list of lists of booleans representing the runs
(always)
(c) (append) (repeat) (sub1) (1) runs
                      #true
             (wrap) #false
    (ZEDbits) (!) runs

(bits->byte) bits
comment: bits is a list of booleans -> output is the base ten integer corresponding to the bit pattern
(always)
(ZEDbits->byte) bits 0

(ZEDbits->byte) bits accumulator
comment: empty bits -> accumulator
(null?) bits
accumulator

(ZEDbits->byte) bits accumulator
comment: first bit is #true -> double the accumulator and increment, then recur on the rest of the bits
(1) bits
(ZEDbits->byte) (!) bits
                (add1) (*) 2 accumulator

(ZEDbits->byte) bits accumulator
comment: first bit is #false -> double the accumulator and then recur on the rest of the bits
(always)
(ZEDbits->byte) (!) bits
                (*) 2 accumulator

(bits->bytes) bits
comment: bits is a list of booleans -> output is the bytes
(always)
(mp) bits->byte (ZEDbits->bytes) bits

(ZEDbits->bytes) list
comment: empty list ->  return the empty list
(null?) list
nil

(ZEDbits->bytes) list
comment: non empty list -> output is a list of eight element lists of booleans
(always)
(c) (first) 8 list
    (ZEDbits->bytes) (-8) list
    
(boolean?) value
comment: any value -> is the value a boolean?
(always)
(two) "boolean?" value

(byte->bits) byte
comment: byte is an integer in the range 0-255 -> output is an eight element list of booleans  
(always)
(append) (repeat) (-) 8 (length) (ZEDbyte->bits) byte
                  #false
         (reverse) (ZEDbyte->bits) byte

(ZEDbyte->bits) byte
comment: byte is zero -> return the empty list
(zero?) byte
nil

(ZEDbyte->bits) byte
comment: byte is odd -> cons #true and recur appropriately
(odd?) byte
(c) #true (ZEDbyte->bits) (halve) (sub1) byte

(ZEDbyte->bits) byte
comment: byte is even -> cons #false and recur appropriately
(even?) byte
(c) #false (ZEDbyte->bits) (halve) byte

(byte-string->path) byte-string
comment: any byte-string that is a valid path -> a path object
(always)
(two) "bytes->path" byte-string

(byte-string-append) byte-string1 byte-string2
comment: takes two byte-strings -> outputs the concatenation
(always)
(three) "bytes-append" byte-string1 byte-string2

(bytes->bits) bytes
comment: bytes is a list of integers in the range 0-255 -> output is a list of booleans
(always)
(reduce-append) (mp) byte->bits bytes

(character->integer) character
comment: any character -> outputs an integer that is the Unicode code-point number
(always)
(two) "char->integer" character

(character->string) character
comment: any character -> outputs a one character string
(always)
(two) "list->string" ("wrap") character

(character?) value
comment: any value -> is it a character?
(always)
(two) "char?" value

(close-input-port) port
comment: takes an input port -> closes it
(always)
(two) "close-input-port" port

(close-output-port) port
comment: takes an output port -> closes it
(always)
(two) "close-output-port" port

(collect-garbage)
comment: force garbage collection
(always)
(one) "collect-garbage"

(count) number
comment: start with a number -> the infinite list of numbers counting up by one
(always)
(c) number (count) (add1) number

(current-memory-use)
comment: returns a count of the bytes of memory occupied by reachable data
(always)
(one) "current-memory-use"

(current-random-number-generator)
comment: the current random number generator
(always)
(one) "current-pseudo-random-generator"

(default-input-port)
comment: the default input port
(always)
(one) "current-input-port"

(default-output-port)
comment: the default output port
(always)
(one) "current-output-port"

(delay) value
comment: takes a value -> delays computation
(always)
(two) "delay" value

(delete-file) path
comment: a valid path -> file is deleted
(always)
(two) "delete-file" path

(delete-file-if-exists) path
comment: a valid path -> file is deleted if it exists
(file-exists?) path
(delete-file) path

(denominator) number
comment: takes an exact number -> returns the denominator
(always)
(two) "denominator" number

(display) port item
comment: takes an output port and an item -> displays item on the output port
(always)
(three) "display" item port

(dr) value
comment: any value -> display it to the default output port and then return it as a value
(always)
(se) (display) (default-output-port) (pr) (ZEDdr) value
     (se) (newline) (default-output-port)
     (se) (newline) (default-output-port)
     value

(ZEDdr) value
comment: value is a pair -> recursively gather upto the first 64 elements of value
(pair?) value
(mp) ZEDdr (first) 64 value

(ZEDdr) value
comment: value is basic -> return the value
(always)
value

(drr) value
comment: any value that is not infinite -> display then return the value
(always)
(se) (display) (default-output-port) (pr) value
     (se) (newline) (default-output-port)
     (se) (newline) (default-output-port)
     value

(end-of-file-object)
comment: end of file object
(always)
"eof"

(end-of-file-object?) value
comment: any value -> is it the end of file object?
(always)
(two) "eof-object?" value

(eq?) symbol1 symbol2
comment: any two symbols -> are they the same symbol?
(always)
(three) "eq?" symbol1 symbol2

(equal?) list1 list2
comment: either list empty -> are the two lists displayed the same?
(or) (null?) list1 (null?) list2
(and) (null?) list1 (null?) list2

(equal?) list1 list2
comment: list1 is not a pair -> are the two lists displayed the same?
(or) (not) (pair?) list1 (not) (pair?) list2
(=) list1 list2

(equal?) list1 list2
comment: the first elements of list1 and list2 are recursively (equal?) -> are the two lists displayed the same?
(always)
(and) (equal?) (1) list1 (1) list2
      (equal?) (!) list1 (!) list2

(even?) integer
comment: any integer -> is the integer even?
(always)
(two) "even?" integer

(exact->inexact) number
comment: an exact number -> returns the inexact representation
(always)
(two) "exact->inexact" number

(fi) function list
comment: empty list -> returns the list of elements that satisfy the function
(null?) list
nil

(fi) function list
comment: first element of list satisfies function -> returns the list of elements that satisfy the function
(two) function (1) list
(c) (1) list (fi) function (!) list

(fi) function list
comment: first element of list does not satisfy function -> returns the list of elements that satisfy the function
(always)
(fi) function (!) list

(file-exists?) path
comment: any path -> does the file exist?
(always)
(two) "file-exists?" path

(file-size) path
comment: any valid path -> returns the file size in bytes
(always)
(two) "file-size" path

(first) number list
comment: list is not a list -> selects the first number elements from the beginning of list
(not) (pair?) list
list

(first) number list
comment: number is zero -> selects the first number elements from the beginning of list
(zero?) number
nil

(first) number list
comment: number is positive -> selects the first number elements from the beginning of list
(positive?) number
(c) (1) list
    (first) (sub1) number
            (!) list

(force) value
comment: takes a value -> forces a promise or returns the value
(always)
(two) "force" value
			
(generate-symbol) base
comment: takes a string or symbol base -> generates a symbol gaurenteed to be unique for the purpose of comparisons
(always)
(two) "gensym" base

(get-file) message
comment: takes a message string -> returns a file path object
(always)
(two) "get-file" message

(get-run) bits
comment: first bit is #true -> returns the first run in bits
(1) bits
(+) 1 (get-run) (!) bits

(get-run) bits
comment: first bit is #false -> returns the first run in bits
(always)
1

(get-text-from-user) title message
comment: provide a title and a message -> returns a string of the user input
(always)
(three) "get-text-from-user" title message

(gr) garbage value
comment: takes a value and a garbage value -> returns the value after displaying the garbage value with (dr)
(always)
(se) (dr) garbage value

(grr) garbage value
comment: takes a value and a garbage value -> returns the value after displaying the garbage value with (drr)
(always)
(se) (drr) garbage value

(halve) number
comment: 
(always)
(/) number 2

(last) list
comment: empty list -> last element of list
(null?) list
err

(last) list
comment: single element list -> last element of list
(null?) (!) list
(1) list

(last) list
comment: multi element list -> last element of list
(always)
(last) (!) list

(length) list
comment: empty list -> returns the length of the list
(null?) list
0

(length) list
comment: non empty list -> returns the length of the list
(always)
(add1) (length) (!) list

(list?) value
comment: empty list -> is value a list?
(null?) value
#true

(list?) value
comment: value is a pair -> is value a list?
(pair?) value
(list?) (!) value

(list?) value
comment: value is not a pair -> is value a list?
(always)
#false

(list->racket) list
comment: empty list -> returns a Racket list
(null?) list
nil

(list->racket) list
comment: non empty list -> returns a Racket list
(always)
("cons") (1) list (list->racket) (!) list

(list->string) list
comment: takes a list -> returns a string representation
(always)
("apply") "string-append" (two) "flatten" (ZEDlist->string) list

(ZEDlist->string) list
comment: empty list -> returns the same list structure but with strings replacing the atoms
(null?) list
nil

(ZEDlist->string) list
comment: list is not a pair -> returns almost the same list structure but with strings replacing the atoms
(not) (pair?) list
(ZEDlist->string) (wrap2) "","" list

(ZEDlist->string) list
comment: the first element of list is the empty list -> returns almost the same list structure but with strings replacing the atoms
(null?) (1) list
(ZEDlist->string) (!) list

(ZEDlist->string) list
comment: the first element of list is a pair -> returns almost the same list structure but with strings replacing the atoms
(pair?) (1) list
("cons") (ZEDlist->string) (1) list
         (ZEDlist->string) (!) list

(ZEDlist->string) list
comment: the first element of list is not a pair -> returns almost the same list structure but with strings replacing the atoms
(always)
("cons") (two) "call-with-output-string" (two) (two) "curry" "display" (1) list
         (ZEDlist->string) (!) list

(make-random-number-generator)
comment: makes a random number generator object
(always)
(one) "make-pseudo-random-generator"

(many) function count value
comment: count is less than one -> returns the value after applying function count times
(<) count 1
value

(many) function count value
comment: count is not less than one -> returns the value after applying function count times
(always)
(many) function (sub1) count (two) function value

(maximum) number1 number2
comment: any two numbers -> returns the maximum of the two
(always)
(three) "max" number1 number2

(member?) value list
comment: empty list -> is value a member of the list?
(null?) list
#false

(member?) value list
comment: the first member of list is value by comparison (=) -> is value a member of the list?
(=) value (1) list
#true

(member?) value list
comment: the first member of list is not value by comparison (=) -> is value a member of the list?
(always)
(member?) value (!) list

(message) list
comment: list is the words of a message -> returns the string which is the words of the message seperated by spaces
(always)
(list->string) (add-between) #space list

(message-box) title message
comment: given a title and message -> produces a message box
(always)
(three) "message-box" title message

(modulo) integer1 integer2
comment: given integer1 and integer2 -> returns integer1 modulo integer2
(always)
(three) "modulo" integer1 integer2

(mp) function list
comment: empty list -> returns the list with every element transformed by function
(null?) list
nil

(mp) function list
comment: list is a pair -> returns the list with every element transformed by function
(pair?) list
(c) (two) function (1) list
    (mp) function (!) list

(mp) function list
comment: list is not a pair -> returns the list with every element transformed by function
(always)
(two) function list

(multiple?) number1 number2
comment: given number1 and number2 -> is number2 an exact multiple of number1?
(always)
(=) 1 (denominator) (/) number2 number1

(negative?) number
comment: any number -> is it negative?
(always)
(<) number 0

(newline) port
comment: takes an output port -> sends a newline to it
(always)
(two) "newline" port

(non) runs
comment: the first run is one -> produces the first integer not equal to one
(=) 1 (1) runs
(non) (!) runs

(non) runs
comment: the first run is greater than one -> produces the first integer not equal to one
(always)
(1) runs

(not) boolean
comment: takes a boolean value -> gives the compliment
(always)
(two) "not" boolean

(null?) list
comment: any list -> is the list empty?
(always)
(two) "null?" list

(number?) value
comment: any value -> is value a number?
(always)
(two) "number?" value

(number->string) number
comment: any number -> returns a string representation
(always)
(two) "number->string" number

(odd?) integer
comment: takes an integer -> is it odd?
(always)
(two) "odd?" integer

(ones) runs
comment: the first run is one -> returns count of leading ones
(=) 1 (1) runs
(add1) (ones) (!) runs

(ones) runs
comment: the first run is not a one -> returns count of leading ones
(always)
0

(open-input-file) path
comment: path to a file -> opens an input port
(always)
(two) "open-input-file" path

(open-output-file) path
comment: path to a file that does not exist -> opens an output port
(always)
(two) "open-output-file" path

(pair?) value
comment: any value -> is it a pair?
(always)
(two) "pair?" value

(path->byte-string) path
comment: takes a path object -> produces a byte-string
(always)
(two) "path->bytes" path

(positive?) number
comment: any number -> is it positive?
(always)
(>) number 0

(pr) value
comment: any value -> outputs a string representation
(always)
(list->string) (ZEDpr) value

(ZEDpr) value
comment: value is a list -> recursively adds in brackets and spaces
(list?) value
(append) (append) (wrap) #[ (add-between) #space (mp) ZEDpr value (wrap) #]

(ZEDpr) value
comment: value is not a list -> recursively adds in brackets and spaces
(always)
value

(predictable-random-bits) seed
comment: takes a seed for the random number generator -> produces an infinite list of rsndom bits
(always)
(se) (two) "current-pseudo-random-generator" (make-random-number-generator)
     (se) (random-seed) seed
     (ZEDpredictable-random-bits1) (current-random-number-generator)

(ZEDpredictable-random-bits1) generator
comment: takes a random number generator -> produces an infinite list of random bits
(always)
(ZEDpredictable-random-bits2) (bit) generator generator

(ZEDpredictable-random-bits2) bit generator
comment: takes a bit and a random number generator -> produces an infinite list of random bits
(always)
(c) bit (ZEDpredictable-random-bits1) generator

(random-number-generator->vector) generator
accessing the underlying Racket/Scheme function
(always)
("apply") "pseudo-random-generator->vector" ("wrap") generator

(random-number-generator?) value
accessing the underlying Racket/Scheme function
(always)
("apply") "pseudo-random-generator?" ("wrap") value

(put-file) message
accessing the underlying Racket/Scheme function
(always)
("apply") "put-file" ("wrap") message

(quotient) numerator denominator
accessing the underlying Racket/Scheme function
(always)
("apply") "quotient" ("wrap2") numerator denominator

(random) generator range
accessing the underlying Racket/Scheme function
(always)
(add1) ("apply") "random" ("wrap2") range generator

(random-number-generator-vector?) value
accessing the underlying Racket/Scheme function
(always)
("apply") "pseudo-random-generator-vector?" ("wrap") value

(random-seed) number
accessing the underlying Racket/Scheme function
(always)
("apply") "random-seed" ("wrap") number

(read) port
accessing the underlying Racket/Scheme function
(always)
("apply") "read" ("wrap") port

(read-byte) port
accessing the underlying Racket/Scheme function
(always)
("apply") "read-byte" ("wrap") port

(read-bytes) path
comment
(always)
(ZEDread-bytes) (open-input-file) path

(ZEDread-bytes) port
comment
(always)
(ZEDread-bytes1) port (read-byte) port

(ZEDread-bytes1) port byte
comment
(end-of-file-object?) byte
(se) (close-input-port) port nil

(ZEDread-bytes1) port byte
comment
(always)
(c) byte (ZEDread-bytes) port

(reduce) final function list
comment
(null?) list
final

(reduce) final function list
comment
(always)
(ZEDreduce) final function (!) list (1) list

(ZEDreduce) final function list accumulator
comment
(null?) list
(three) function accumulator final

(ZEDreduce) final function list accumulator
comment
(always)
(ZEDreduce) final function (!) list (three) function accumulator (1) list

(reduce-append) list
comment
(null?) list
nil

(reduce-append) list
comment
(null?) (1) list
(reduce-append) (!) list

(reduce-append) list
comment
(always)
(ZEDreduce-append) (1) list (!) list

(ZEDreduce-append) list1 list2
comment
(null?) list1
(reduce-append) list2

(ZEDreduce-append) list1 list2
comment
(always)
(c) (1) list1 (ZEDreduce-append) (!) list1 list2

(ref) number list
comment
(=) number 1
(1) list

(ref) number list
comment
(>) number 1
(ref) (sub1) number (!) list

(remove) value list
comment
(null?) list
nil

(remove) value list
comment
(=) value (1) list
(!) list

(remove) value list
comment
(always)
(c) (1) list (remove) value (!) list

(remove-with-equal) value list
comment
(equal?) value (1) list
(!) list

(remove-with-equal) value list
comment
(always)
(c) (1) list (remove-with-equal) value (!) list

(repeat) number item
comment
(zero?) number
nil

(repeat) number item
comment
(positive?) number
(c) item (repeat) (sub1) number item

(replace-output-file) output-file
comment
(always)
("apply1") "open-output-file"
           ("wrap") output-file
           "#:exists"
           "'replace"                          

(reverse) list
comment
(always)
(ZEDreverse) list nil

(ZEDreverse) list reverse
comment
(null?) list
reverse

(ZEDreverse) list reverse
comment
(always)
(ZEDreverse) (!) list
             (c) (1) list reverse

(runs) bits
nil
(null?) bits
nil

(runs) bits
[#false #true #false ...]
(always)
(c) (get-run) bits
    (runs) (tails) (get-run) bits
                   bits

(sort) less-than? list
comment
(always)
("apply") "sort" ("wrap2") (list->racket) list less-than?

(space) port
comment
(always)
(display) port #space

(string?) value
accessing the underlying Racket/Scheme function
(always)
("apply") "string?" ("wrap") value

(string->list) string
accessing the underlying Racket/Scheme function
(always)
("apply") "string->list" ("wrap") string

(sub1) number
accessing the underlying Racket/Scheme function
(always)
("apply") "sub1" ("wrap") number

(sum) numbers
[1 2 5 3]
(always)
(ZEDsum) numbers 0

(ZEDsum) numbers accumulator
nil 55
(null?) numbers
accumulator

(ZEDsum) numbers accumulator
[1 2 5 3] 5
(always)
(ZEDsum) (!) numbers (+) accumulator (1) numbers

(symbol?) value
accessing the underlying Racket/Scheme function
(always)
("apply") "symbol?" ("wrap") value

(symbol->string) symbol
accessing the underlying Racket/Scheme function
(always)
("apply") "symbol->string" ("wrap") symbol

(tails) number list
comment
(or) (null?) list
     (=) number 0
list

(tails) number list
comment
(>) number 0
(tails) (sub1) number (!) list

(vector->random-number-generator) vector
accessing the underlying Racket/Scheme function
(always)
("apply") "vector->pseudo-random-generator" ("wrap") vector

(wrap) a
comment
(always)
(c) a nil

(wrap2) a b
comment
(always)
(c) a (wrap) b

(wrap3) a b d
comment
(always)
(c) a (wrap2) b d

(wrap4) a b d e
comment
(always)
(c) a (wrap3) b d e

(wrap5) a b d e f
comment
(always)
(c) a (wrap4) b d e f

(wrap6) a b d e f g
comment
(always)
(c) a (wrap5) b d e f g

(wrap7) a b d e f g h
comment
(always)
(c) a (wrap6) b d e f g h

(wrap8) a b d e f g h i
comment
(always)
(c) a (wrap7) b d e f g h i

(wrap9) a b d e f g h i j
comment
(always)
(c) a (wrap8) b d e f g h i j

(wrap10) a b d e f g h i j k
comment
(always)
(c) a (wrap9) b d e f g h i j k

(wrap11) a b d e f g h i j k l
comment
(always)
(c) a (wrap10) b d e f g h i j k l

(wrap12) a b d e f g h i j k l m
comment
(always)
(c) a (wrap11) b d e f g h i j k l m

(wrap13) a b d e f g h i j k l m n
comment
(always)
(c) a (wrap12) b d e f g h i j k l m n

(wrap14) a b d e f g h i j k l m n o
comment
(always)
(c) a (wrap13) b d e f g h i j k l m n o

(wrap15) a b d e f g h i j k l m n o p
comment
(always)
(c) a (wrap14) b d e f g h i j k l m n o p

(wrap16) a b d e f g h i j k l m n o p q
comment
(always)
(c) a (wrap15) b d e f g h i j k l m n o p q

(write-byte) port byte
accessing the underlying Racket/Scheme function
(always)
("apply") "write-byte" ("wrap2") byte port

(write-bytes) path list
comment
(always)
(ZEDwrite-bytes) (open-output-file) path list

(ZEDwrite-bytes) port list
comment
(null?) list
(close-output-port) port

(ZEDwrite-bytes) port list
comment
(always)
(se) (write-byte) port (1) list
     (ZEDwrite-bytes) port (!) list

(xor) bit1 bit2
comment
(and) (boolean?) bit1
      (boolean?) bit2
(not) (=) bit1 bit2

(zero?) number
comment
(always)
(=) number 0

(zip) bits1 bits2
[ ] [#true #true #true ...]
(or) (null?) bits1 (null?) bits2
nil

(zip) bits1 bits2
[#false #true #false ...] [#true #true #true ...]
(always)
(c) (xor) (1) bits1 (1) bits2
    (zip) (!) bits1 (!) bits2